strat = nlist(repay,repay)
# Let the strategies play against each other
run.rep.game(delta=0.9, game=game, strat = strat, T.min = 2)
debug.restore("repay",i = 1, t = 2)
obs
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
game = make.payment.message.pd.game(err.D.prob=0.6, private.signals=TRUE)
# Pick a pair of strategies
strat = nlist(repay,repay)
# Let the strategies play against each other
run.rep.game(delta=0.9, game=game, strat = strat, T.min = 2)
debug.restore("repay",i = 1, t = 2)
obs
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
restore.point("run.rep.game")
gbos$do.store = do.store
# We have a separate function for multistage games
if (length(game$stages)>0) {
return(run.rep.multistage.game(delta=delta, game=game, strat=strat, T.min=T.min,T.max = T.max,detailed.return = detailed.return, strat.seed=strat.seed, game.seed = game.seed))
}
if (is.null(game.seed))
game.seed = draw.seed()
if (is.null(strat.seed))
strat.seed = draw.seed()
c(game.seed,strat.seed)
#Store seeds to replicate for debugging purposes
gbos$game.seed = game.seed
gbos$strat.seed = strat.seed
init.random.state("game",game.seed)
init.random.state("strat",strat.seed)
set.random.state("game")
T.rand = rnbinom(1,size=1,prob=1-delta)
T = pmin(T.min + T.rand,T.max)
strat.id = seq_along(strat)
n.strat = length(strat.id)
if (n.strat != game$n) {
stop(paste("The game requires ",game$n, " players but you submitted ", n.strat, " strategies."))
}
if (game$private.signals) {
obs = vector("list",game$n)
} else {
obs = NULL
}
obs
denv = new.env()
a = vector("list",n.strat)
game.states = game$init.states
# Names of strategy states
sts.names = lapply(strat.id, function(i) {
setdiff(names(formals(strat[[i]])),c("obs", "i","t","game","..."))
})
strat.states = lapply(strat.id, function(i) {
list()
})
u = rep(0,game$n)
delta.compound = 1
t = 1
if (detailed.return) {
start.strat.states = strat.states
start.game.states = game.states
}
# Set the random state for the strategy
set.random.state("strat")
# 1. Evaluate strategies of each player
for (i in strat.id) {
obs.i = get.obs.i(obs = obs, i = i, game = game)
# Use only those strat.par that are not returned as a strat.state
act.strat.par = strat.par[[i]][setdiff(names(strat.par),names(strat.states[[i]]))]
args = c(list(obs = obs.i,i=i,t=t, game=game),game.states,strat.states[[i]], act.strat.par)
tryCatch(
strat.res <- do.call(strat[[i]],args),
error = function(e) {
message("Error in evaluating strategy ", names(strat)[i], " in period t=", t, " for player i=",i,"\nERROR.HIST:")
hist = denv$df[1:t,]
print(tail(hist))
assign(".BOS.ERROR.HIST",hist,.GlobalEnv)
assign(".BOS.ERROR.t",t,.GlobalEnv)
assign(".BOS.ERROR.i",i,.GlobalEnv)
stop(as.character(e), call.=FALSE)
}
)
strat.res = format.strat.res(t=t,i=i,game=game,strat.res=strat.res)
a[[i]] = strat.res$a
strat.states[[i]] = strat.res$strat.states
game$check.action(ai=a[[i]],i=i,t=t)
}
names(a) = game$a.names
# 2. Evaluate game results
set.random.state("game")
results = game$results.fun(a=a,game.states=game.states,game=game)
old.obs = obs
obs = results$obs
obs
get.obs.i(obs = obs, i = i, game = game)
source('D:/libraries/StratTourn/StratTourn/R/rep_game.r')
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
game = make.payment.message.pd.game(err.D.prob=0.6, private.signals=TRUE)
# Pick a pair of strategies
strat = nlist(repay,repay)
# Let the strategies play against each other
run.rep.game(delta=0.9, game=game, strat = strat, T.min = 2)
source('D:/libraries/StratTourn/StratTourn/R/rep_game.r')
source('D:/libraries/StratTourn/StratTourn/R/rep_game.r')
game = make.payment.message.pd.game(err.D.prob=0.6, private.signals=TRUE)
# Pick a pair of strategies
strat = nlist(repay,repay)
# Let the strategies play against each other
run.rep.game(delta=0.9, game=game, strat = strat, T.min = 2)
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
restore.point("rep.game.store.detailed.return")
t
denv$df[t,"t"] = t
denv$df[t,denv$a.names] = unlist(a)
denv$df[t,denv$payoff.names] = payoffs
denv$obs.cols
unlist(lapply(1:n, function(i) {
sapply(seq_along(denv$obs.len[[i]]), function(j) {
if (j > length(obs[[i]]))
return(rep(NA,denv$obs.len[[i]][j]))
to.length(obs[[i]][[j]],denv$obs.len[[i]][j])
})
}))
obs
denv$obs.len
restore.point("rep.game.store.detailed.return_t1")
# Get a list of all names
a.names = lapply(1:n, function(i) {
ai = a[[i]]
if (is.list(ai))
return(paste0(names(ai),i))
return(paste0("a",i))
})
a.names = do.call("c",a.names)
payoff.names = paste0("pi",1:n)
a.names
ex.obs = game$example.obs()
ex.obs
obs.names = str.combine("obs_",names(ex.obs))
obs.names
obs.len = sapply(ex.obs,length)
obs.len
obs.names = lapply(1:n, function(i) {
str.combine("obs",i,"_",names(ex.obs[[i]]))
})
obs.names
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
game = make.payment.message.pd.game(err.D.prob=0.25, private.signals=TRUE)
# Pick a pair of strategies
strat = nlist(repay,repay)
# Let the strategies play against each other
run.rep.game(delta=0.9, game=game, strat = strat, T.min = 2)
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
game = make.payment.message.pd.game(err.D.prob=0.25, private.signals=TRUE)
# Pick a pair of strategies
strat = nlist(repay,repay)
# Let the strategies play against each other
run.rep.game(delta=0.9, game=game, strat = strat, T.min = 2)
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
game = make.payment.message.pd.game(err.D.prob=0.25, private.signals=TRUE)
# Pick a pair of strategies
strat = nlist(repay,repay)
# Let the strategies play against each other
run.rep.game(delta=0.9, game=game, strat = strat, T.min = 2)
debug.restore("repay",i = 1, t = 2)
obs
j=3-i
if (obs$a[i]==obs$a[j]) {
net.stage.payoff = 0
} else if (obs$a[i]=="C") {
net.stage.payoff = game$param$uCD-game$param$uDC
} else {
net.stage.payoff = game$param$uDC-game$param$uCD
}
obs$a[i]
obs
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
restore.point("run.rep.game")
gbos$do.store = do.store
# We have a separate function for multistage games
if (length(game$stages)>0) {
return(run.rep.multistage.game(delta=delta, game=game, strat=strat, T.min=T.min,T.max = T.max,detailed.return = detailed.return, strat.seed=strat.seed, game.seed = game.seed))
}
if (is.null(game.seed))
game.seed = draw.seed()
if (is.null(strat.seed))
strat.seed = draw.seed()
c(game.seed,strat.seed)
#Store seeds to replicate for debugging purposes
gbos$game.seed = game.seed
gbos$strat.seed = strat.seed
init.random.state("game",game.seed)
init.random.state("strat",strat.seed)
set.random.state("game")
T.rand = rnbinom(1,size=1,prob=1-delta)
T = pmin(T.min + T.rand,T.max)
strat.id = seq_along(strat)
n.strat = length(strat.id)
if (n.strat != game$n) {
stop(paste("The game requires ",game$n, " players but you submitted ", n.strat, " strategies."))
}
if (game$private.signals) {
obs = vector("list",game$n)
} else {
obs = NULL
}
denv = new.env()
a = vector("list",n.strat)
game.states = game$init.states
# Names of strategy states
sts.names = lapply(strat.id, function(i) {
setdiff(names(formals(strat[[i]])),c("obs", "i","t","game","..."))
})
strat.states = lapply(strat.id, function(i) {
list()
})
u = rep(0,game$n)
delta.compound = 1
t = 1
#if (t==2)
#  stop()
if (detailed.return) {
start.strat.states = strat.states
start.game.states = game.states
}
# Set the random state for the strategy
set.random.state("strat")
# 1. Evaluate strategies of each player
for (i in strat.id) {
obs.i = get.obs.i(obs = obs, i = i, game = game)
# Use only those strat.par that are not returned as a strat.state
act.strat.par = strat.par[[i]][setdiff(names(strat.par),names(strat.states[[i]]))]
args = c(list(obs = obs.i,i=i,t=t, game=game),game.states,strat.states[[i]], act.strat.par)
tryCatch(
strat.res <- do.call(strat[[i]],args),
error = function(e) {
message("Error in evaluating strategy ", names(strat)[i], " in period t=", t, " for player i=",i,"\nERROR.HIST:")
hist = denv$df[1:t,]
print(tail(hist))
assign(".BOS.ERROR.HIST",hist,.GlobalEnv)
assign(".BOS.ERROR.t",t,.GlobalEnv)
assign(".BOS.ERROR.i",i,.GlobalEnv)
stop(as.character(e), call.=FALSE)
}
)
strat.res = format.strat.res(t=t,i=i,game=game,strat.res=strat.res)
a[[i]] = strat.res$a
strat.states[[i]] = strat.res$strat.states
game$check.action(ai=a[[i]],i=i,t=t)
}
names(a) = game$a.names
# 2. Evaluate game results
set.random.state("game")
results = game$results.fun(a=a,game.states=game.states,game=game)
old.obs = obs
obs = results$obs
game.states = results$game.states
obs
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
game = make.payment.message.pd.game(err.D.prob=0.25, private.signals=TRUE)
# Pick a pair of strategies
strat = nlist(repay,repay)
# Let the strategies play against each other
run.rep.game(delta=0.9, game=game, strat = strat, T.min = 2)
restore.point("rep.game.store.detailed.return_t1")
# Get a list of all names
a.names = lapply(1:n, function(i) {
ai = a[[i]]
if (is.list(ai))
return(paste0(names(ai),i))
return(paste0("a",i))
})
a.names = do.call("c",a.names)
payoff.names = paste0("pi",1:n)
ex.obs = game$example.obs()
ex.obs
names(game)
ex.obs
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
source('D:/libraries/StratTourn/StratTourn/R/rep_game.r')
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
game = make.payment.message.pd.game(err.D.prob=0.25, private.signals=TRUE)
# Pick a pair of strategies
strat = nlist(repay,repay)
# Let the strategies play against each other
run.rep.game(delta=0.9, game=game, strat = strat, T.min = 2)
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
source('D:/libraries/StratTourn/StratTourn/R/rep_game.r')
source('D:/libraries/StratTourn/StratTourn/R/rep_game.r')
source('D:/libraries/StratTourn/StratTourn/R/rep_game.r')
game = make.payment.message.pd.game(err.D.prob=0.25, private.signals=TRUE)
# Pick a pair of strategies
strat = nlist(repay,repay)
# Let the strategies play against each other
run.rep.game(delta=0.9, game=game, strat = strat, T.min = 2)
restore.point("rep.game.store.detailed.return_t1")
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
game = make.payment.message.pd.game(err.D.prob=0.25, private.signals=TRUE)
# Pick a pair of strategies
strat = nlist(repay,repay)
# Let the strategies play against each other
run.rep.game(delta=0.9, game=game, strat = strat, T.min = 2)
source('D:/libraries/StratTourn/StratTourn/R/rep_game.r')
source('D:/libraries/StratTourn/StratTourn/R/rep_game.r')
source('D:/libraries/StratTourn/StratTourn/R/rep_game.r')
source('D:/libraries/StratTourn/StratTourn/R/rep_game.r')
source('D:/libraries/StratTourn/StratTourn/R/rep_game.r')
source('D:/libraries/StratTourn/StratTourn/R/rep_game.r')
source('D:/libraries/StratTourn/StratTourn/R/rep_game.r')
source('D:/libraries/StratTourn/StratTourn/R/rep_game.r')
game = make.payment.message.pd.game(err.D.prob=0.25, private.signals=TRUE)
# Pick a pair of strategies
strat = nlist(repay,repay)
# Let the strategies play against each other
run.rep.game(delta=0.9, game=game, strat = strat, T.min = 2)
source('D:/libraries/StratTourn/StratTourn/R/rep_game.r')
run.rep.game(delta=0.9, game=game, strat = strat, T.min = 2)
tarceback()
traceback()
restore.point("rep.game.store.detailed.return_t1")
# Get a list of all names
a.names = lapply(1:n, function(i) {
ai = a[[i]]
if (is.list(ai))
return(paste0(names(ai),i))
return(paste0("a",i))
})
a.names = do.call("c",a.names)
payoff.names = paste0("pi",1:n)
ex.obs = game$example.obs()
# Get names of observations
if (!game$private.signals) {
obs.names = str.combine("obs_",names(ex.obs))
obs.len = sapply(ex.obs,length)
obs.cols = obs.names.to.cols(obs.names,obs.len)
} else {
public.obs.names = str.combine("obs_",game$public.obs)
private.obs.names = lapply(1:n, function(i) {
str.combine("obs",i,"_",game$private.obs[[i]])
})
public.obs.len = sapply(ex.obs[[1]][game$public.obs],length)
names(public.obs.len) = game$public.obs
private.obs.len = lapply(1:n, function(i) {
ret = sapply(ex.obs[[i]][game$private.obs[[i]]], length)
names(ret) = game$public.obs[[i]]
ret
})
public.obs.cols = obs.names.to.cols(public.obs.names,public.obs.len)
private.obs.cols = unlist(lapply(1:n, function(i) {
obs.names.to.cols(private.obs.names[[i]],private.obs.len[[i]])
}))
}
public.obs.names
private.obs.names
public.obs.len
names(public.obs.len) = game$public.obs
private.obs.len
private.obs.len = lapply(1:n, function(i) {
ret = sapply(ex.obs[[i]][game$private.obs[[i]]], length)
names(ret) = game$private.obs[[i]]
ret
})
private.obs.len
source('D:/libraries/StratTourn/StratTourn/R/rep_game.r')
public.obs.cols = obs.names.to.cols(public.obs.names,public.obs.len)
private.obs.cols = unlist(lapply(1:n, function(i) {
obs.names.to.cols(private.obs.names[[i]],private.obs.len[[i]])
}))
public.obs.cols
private.obs.cols = unlist(lapply(1:n, function(i) {
obs.names.to.cols(private.obs.names[[i]],private.obs.len[[i]])
}))
private.obs.cols
# Get a list of all strategy state names
strat.states.names = lapply(1:n, function(i) {
si = next.strat.states[[i]]
str.combine(names(si),"_",i)
})
#strat.states.names = lapply(1:n, function(i) {
#  si = setdiff(names(formals(strat[[i]])),c("obs", "i","t","game","..."))
#  str.combine(si,"_",i)
#})
strat.states.len = lapply(1:n, function(i) {
sapply(next.strat.states[[i]], length)
})
strat.states.cols = unlist(lapply(1:n, function(i) {
sapply(seq_along(strat.states.names[[i]]), function(j) {
len = min(strat.states.len[[i]][j],max.state.vector.size)
if (len > 1) {
str.combine(strat.states.names[[i]][j],"_",
1:len)
} else {
strat.states.names[[i]][j]
}
})
}))
next.strat.states.cols = str.combine("next_",strat.states.cols)
game.states.names = names(game.states)
game.states.len = sapply(game.states,length)
game.states.cols = obs.names.to.cols(game.states.names, pmin(game.states.len,max.state.vector.size))
game.states.cols
next.game.states.cols = str.combine("next_",game.states.cols)
game$private.signals
denv$public.obs.len = public.obs.len
denv$public.obs.cols = public.obs.cols
denv$private.obs.len = private.obs.len
denv$private.obs.cols = private.obs.cols
col.names = c("t",unlist(c(game.states.cols,public.obs.cols,private.obs.cols,a.names,payoff.names,strat.states.cols)))
col.names
df = as.data.frame(matrix(NA,T,length(col.names)))
names(df)=col.names
denv$df = df
denv$a.names = a.names
denv$payoff.names = payoff.names
denv$strat.states.len = strat.states.len
denv$strat.states.cols = strat.states.cols
denv$next.strat.states.cols = next.strat.states.cols
denv$game.states.len = game.states.len
denv$game.states.cols = game.states.cols
denv$next.game.states.cols = next.game.states.cols
denv$df[t,"t"] = t
denv$df[t,denv$a.names] = unlist(a)
denv$df[t,denv$payoff.names] = payoffs
denv$df[t,denv$public.obs.cols] =
unlist(lapply(game$public.obs, function(j) {
if (!(j %in% names(obs[[1]])))
return(rep(NA,denv$public.obs.len[j]))
to.length(obs[[1]][[j]],denv$public.obs.len[j])
}))
unlist(lapply(game$public.obs, function(j) {
if (!(j %in% names(obs[[1]])))
return(rep(NA,denv$public.obs.len[j]))
to.length(obs[[1]][[j]],denv$public.obs.len[j])
}))
denv$public.obs.cols
obs[[1]]
denv$public.obs.len[j]
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
game = make.payment.message.pd.game(err.D.prob=0.25, private.signals=TRUE)
# Pick a pair of strategies
strat = nlist(repay,repay)
# Let the strategies play against each other
run.rep.game(delta=0.9, game=game, strat = strat, T.min = 2)
run.rep.game(delta=0.9, game=game, strat = strat, T.min = 2)
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
probably.nice <- function(obs,i,t,game,P_i=0.5,P_a=0.5, threshold=0.25, Fratio=0.4){
#Fratio: Familiarity Ratio -> 1 means "nice guy" 0 means "Anti nice guy"
debug.store("probably.nice",i,t)
debug.restore("probably.nice",i=2,t=2)
j=3-i
P_D <- game$params$err.D.prob
P_C <- 0
#Update beliefs
if(t==1){
#do nothing
} else {
#Update of P_a
P_a_old <- P_a
#The other guy would assume, that I am me, given what he knows about me, given that he is me
if(P_i>=threshold){
if(obs$a[j] == "C"){
P_a <- P_a*(1-P_D)/(P_a*(1-P_D)+(1-P_a)*(P_C+Fratio*(1-P_D-P_C)))
} else { # Case Defect
P_a <- P_a*P_D/(P_a*(P_D)+(1-P_a)*(P_D + (1-Fratio)*(1-P_D-P_C)))
}
} else { # other guy thinks I am evil
if(obs$a[j] == "C"){
P_a <- P_a*P_C/(P_a*P_C + (1-P_a)*(P_C + (1-Fratio)*(1-P_D-P_C)))
} else {
P_a <- P_a*(1-P_C)/(P_a*(1-P_C)+(1-P_a)*(P_D + Fratio*(1-P_D-P_C)))
}
}
#Update my view of myself based on his knowledge
if(P_a_old>=threshold){
if(obs$a[i] == "C"){
P_i <- P_i*(1-P_D)/(P_i*(1-P_D)+(1-P_i)*(P_C+Fratio*(1-P_D-P_C)))
} else { # Case Defect
P_i <- P_i*P_D/(P_i*(P_D)+(1-P_i)*(P_D + (1-Fratio)*(1-P_D-P_C)))
}
} else { # other guy thinks I am evil so he should play D
if(obs$a[i] == "C"){
P_i <- P_i*P_C/(P_i*P_C + (1-P_i)*(P_C + (1-Fratio)*(1-P_D-P_C)))
} else {
P_i <- P_i*(1-P_C)/(P_i*(1-P_C)+(1-P_i)*(P_D + Fratio*(1-P_D-P_C)))
}
}
}
#If I think he is me, than cooperate
if(P_a>=threshold){
return(list(a="C",P_i=P_i,P_a=P_a, threshold=threshold))
} else {
return(list(a="D",P_i=P_i,P_a=P_a, threshold=threshold))
}
}
game = make.pd.game(err.D.prob=0.15)
delta = 0.95
sim = NULL
set.storing(TRUE)
sim = study.actions.and.states(strats=nlist(net.nice0, ),game=game, delta=delta, T=20, R = 50, sim=sim)
sim = study.actions.and.states(strats=nlist(net.nice,net.nice ),game=game, delta=delta, T=20, R = 50, sim=sim)
sim
source('D:/libraries/StratTourn/StratTourn/R/study_strats.r')
source('D:/libraries/StratTourn/StratTourn/R/pdgame_sim_moneycom.r')
list(a=10,list(b=3,c=2))
as.character(list(a=10,list(b=3,c=2)))
deparse(list(a=10,list(b=3,c=2)))
