<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Analyzing Cooperation with Game Theory and Simulation</title>

<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 12px;
   margin: 8px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre {	
   margin-top: 0;
   max-width: 95%;
   border: 1px solid #ccc;
   white-space: pre-wrap;
}

pre code {
   display: block; padding: 0.5em;
}

code.r, code.cpp {
   background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}

</style>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: rgb(88, 72, 246)
   }

   pre .number {
     color: rgb(0, 0, 205);
   }

   pre .comment {
     color: rgb(76, 136, 107);
   }

   pre .keyword {
     color: rgb(0, 0, 255);
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: rgb(3, 106, 7);
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>


<!-- MathJax scripts -->
<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/2.0-latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



</head>

<body>
<h1>Analyzing Cooperation with Game Theory and Simulation</h1>

<h1>Task Set 2: Noisy Prisoners&#39; Dilemma with Payments, Messages and Private Signals</h1>

<p><strong>Date: 2013-11-19</strong>
<strong>Author: Sebastian Kranz (<a href="mailto:sebastian.kranz@uni-ulm.de">sebastian.kranz@uni-ulm.de</a>)</strong></p>

<h2>New teams</h2>

<ul>
<li>We will randomly assign new teams for task 2 and put the teams on moodle. You can pick new team names.</li>
<li>On the Moodle site of the seminar, you find a file <strong>coop2_vorlage.Rmd</strong>, which you can download and open in RStudio. You should insert your solutions to all 3 scenarios and a description of your strategies in this file.</li>
</ul>

<h2>Tentative time schedule for second task set</h2>

<ul>
<li><strong>Mo. 02.12.</strong> Help Session 1 &amp; Explanation of Extra-Task for Master Students</li>
<li><strong>Th. 05.12.</strong> Please send us preliminary strategies for all three scenarios</li>
<li><strong>Mo. 09.12.</strong> Help Session 2 and presentation of preliminary results</li>
<li><strong>Th. 12.12.</strong> Please send us your final strategies for all scenarios</li>
<li><strong>Mo. 16.12.</strong> Discussion of final strategies for scenario 3.</li>
<li><strong>Th. 09.01.</strong> Send your answer strategies</li>
<li><strong>Mo. 13.01.</strong> Presentation of final results</li>
</ul>

<h2>Task 2</h2>

<p>Develop strategies for the three different scenarios explained below. All three scenarios use the following parameters:</p>

<pre><code class="r">delta = 0.95
err.D.prob = 0.15
err.C.prob = 0
</code></pre>

<h3>Scenario 1: Noisy PD Game with Payments and Messages</h3>

<p>In many real world relationships parties can communicate with each other and can also make monetary payments. We consider an extended version of the previous noisy prisoners&#39; dilemma game, that accounts for these possibilities. </p>

<h4>An example strategy</h4>

<pre><code class="r">
secret.code = function(obs, i, t, game, ...) {
    debug.store(&quot;secret.code&quot;, i = i, t = t)
    debug.restore(&quot;secret.code&quot;, i = 1, t = 2)


    # In t=0, cooperate, make a random payment, and send message with code.word
    # (There is abolutely no reason for this payment)
    if (t == 1) 
        return(nlist(a = &quot;C&quot;, pay = round(runif(1, 0, 2), 1), m = list(code.word = 42)))

    a = obs$a  # observed actions
    pay = obs$pay  # previous payment
    m = obs$m  # previous messages
    prand = obs$prand  # a random number that is the same for both players

    j = 3 - i
    # Check if the other player sent a message with the correct code.word
    correct.code = FALSE
    if (has.field(m[[j]], &quot;code.word&quot;, type = &quot;numeric&quot;, length = 1)) {
        if (m[[j]]$code.word == 42) {
            correct.code = TRUE
        }
    }

    if (correct.code) {
        return(nlist(a = &quot;C&quot;, pay = pay[j], m = list(code.word = 42)))
    } else {
        return(nlist(a = &quot;D&quot;, pay = 0, m = list(code.word = 42)))
    }
}
</code></pre>

<p>A strategy must return the following objects:</p>

<ul>
<li>an action a \( \in \) {&ldquo;C&rdquo;,&ldquo;D&rdquo;}</li>
<li>a payment <em>pay &gt;= 0</em> to the other player. A positive payment by player i will be simply subtracted from i&#39;s payoff and added to j&#39;s  payoff, i.e. players are risk-neutral.</li>
<li>a message <em>m</em> that can be a single variable or a list of different components. A message has no direct payoff impact, but may be used to exchange information.</li>
</ul>

<p>The observations <em>obs</em> contain corresponding elements obs$a, obs$m, and obs$pay. Furthermore, players observe a variable obs$prand, which is just a random number between 0 and 1, which is the same for both players. (Game theorists call such a random number a <em>public randomization device</em>. It might be useful in some scenarios by allowing players to act in a coordinated fashion.)</p>

<p>A game object is generated with the following function call.</p>

<pre><code class="r">library(StratTourn)
# Initialize game with private monitoring, by setting private.signals=TRUE
game = make.payment.message.pd.game(err.D.prob = err.D.prob)
</code></pre>

<p>Let us play secret.code 10 times against itself</p>

<pre><code class="r">res = run.rep.game(strat = nlist(secret.code, secret.code), game = game, delta = delta, 
    T.min = 10, T.max = 10)
res
</code></pre>

<pre><code>## $hist
##     t obs_a1 obs_a2 obs_pay1 obs_pay2 obs_m1 obs_m2 obs_prand a1 pay1 m1
## 1   1   &lt;NA&gt;   &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;   &lt;NA&gt;   &lt;NA&gt;      &lt;NA&gt;  C  0.7 42
## 2   2      D      C      0.7        1     42     42     0.077  C    1 42
## 3   3      C      C        1      0.7     42     42     0.701  C  0.7 42
## 4   4      C      D      0.7        1     42     42       0.3  C    1 42
## 5   5      C      C        1      0.7     42     42     0.194  C  0.7 42
## 6   6      D      C      0.7        1     42     42     0.569  C    1 42
## 7   7      C      C        1      0.7     42     42     0.269  C  0.7 42
## 8   8      C      D      0.7        1     42     42      0.42  C    1 42
## 9   9      C      C        1      0.7     42     42      0.97  C  0.7 42
## 10 10      C      C      0.7        1     42     42     0.226  C    1 42
##    a2 pay2 m2 pi1 pi2
## 1   C    1 42 1.3 0.7
## 2   C  0.7 42 0.7 1.3
## 3   C    1 42 1.3 0.7
## 4   C  0.7 42 0.7 1.3
## 5   C    1 42 1.3 0.7
## 6   C  0.7 42 0.7 1.3
## 7   C    1 42 1.3 0.7
## 8   C  0.7 42 0.7 1.3
## 9   C    1 42 1.3 0.7
## 10  C  0.7 42 0.7 1.3
## 
## $u
## [1] 1.0077 0.9923
</code></pre>

<p>The ouptut shows the history of the different actions a, messages m and payments pay.</p>

<h4>Avoiding errors when handling messages</h4>

<p>The strategy <em>secret.code</em> implements an obvious idea given that messages are possible: players send a code word in their message: m$code.word=42. If also the other player sends a message with the correct code word, the player cooperates and otherwise the player defects. (If the message is correct a player may also make a payment. There is no special reason for this, except to illustrate that payments are possibly),</p>

<p>If your strategy interprets messages, you have to be careful, that your strategy does not create an error when it plays against a strategy that sends different messages. Consider, the case that our strategy secret.code would just check for the code.word by typing:</p>

<pre><code class="r">if (m[[j]]$code.word == 42) {
    correct.code = TRUE
}
</code></pre>

<p>Now assume it plays against a strategy that has a message m=&ldquo;hi&rdquo;. We would get an error, since the message has no field code.word.</p>

<pre><code class="r">m = list(list(code.word = 42), &quot;hi&quot;)
j = 2
if (m[[j]]$code.word == 42) {
    correct.code = TRUE
}
</code></pre>

<pre><code>## Error: $ operator is invalid for atomic vectors
</code></pre>

<p>For this purpose there is the function has.field that can check whether a message has a particular field. The function can also check whether that field is of a particular data type (you get the type of variable x, by typing class(x)) and length. The code we actually used therefore first calls has.field. It runs without error for all sorts of messages.</p>

<pre><code class="r">m = list(list(code.word = 42), &quot;hi&quot;)
j = 2
if (has.field(m[[j]], &quot;code.word&quot;, type = &quot;numeric&quot;, length = 1)) {
    if (m[[j]]$code.word == 42) {
        correct.code = TRUE
    }
}
</code></pre>

<h4>Using messages for secret codes is a bit boring&hellip;</h4>

<p>While a strategy will secret.code probably look like a winner in the first stage of the tournament, it won&#39;t remain stable, once we run the second stage, where the competing teams see the code of your strategy and can device a best reply. For example, the following strategy is a simple best reply that extremely destabilizes <em>secret.code</em>:</p>

<pre><code class="r">secret.code.basher = function(obs, i, t, game, ...) {
    return(nlist(a = &quot;D&quot;, pay = 0, m = list(code.word = 42)))
}
</code></pre>

<pre><code class="r">res = run.rep.game(strat = nlist(secret.code, secret.code.basher), game = game, 
    delta = 0.98, T.min = 5, T.max = 5)
res
</code></pre>

<pre><code>## $hist
##   t obs_a1 obs_a2 obs_pay1 obs_pay2 obs_m1 obs_m2 obs_prand a1 pay1 m1 a2
## 1 1   &lt;NA&gt;   &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;   &lt;NA&gt;   &lt;NA&gt;      &lt;NA&gt;  C  0.5 42  D
## 2 2      C      D      0.5        0     42     42      0.92  C    0 42  D
## 3 3      D      D        0        0     42     42      0.81  C    0 42  D
## 4 4      C      D        0        0     42     42      0.88  C    0 42  D
## 5 5      C      D        0        0     42     42      0.18  C    0 42  D
##   pay2 m2  pi1 pi2
## 1    0 42 -1.5 2.5
## 2    0 42 -1.0 2.0
## 3    0 42 -1.0 2.0
## 4    0 42 -1.0 2.0
## 5    0 42 -1.0 2.0
## 
## $u
## [1] -1.104  2.104
</code></pre>

<p>In a sense, secret codes are boring in our setting, since your strategies will be make known to all other teams. Of course, you could write your strategy in a fashion that is very hard to understand for other teams, so that it will be complicated to understand your secret code. However, you are asked to describe your strategy  very well, to make it easy to understand for everybody. Since this is add odds with hidding somewhere a secret code, we have the following guide line:</p>

<pre><code>**Try not to win by hiding secret code phrases that strategies use to identify each other. Describe your strategy as clearly as possible. Don&#39;t try to win by hoping that other teams don&#39;t understand your strategy!**
</code></pre>

<h4>If I shall not hide secret codes, for what do I need messages?</h4>

<p>Actually, I don&#39;t believe that messages are useful in Scenario 1. However, messages may potentially be quite useful in Scenario 2. </p>

<h4>What about the payments, do I need them for anything?</h4>

<p>Try out yourself whether payments can be useful to improve strategies&hellip;</p>

<h3>Scenario 2: Noisy PD Game with Private Monitoring, Payments and Messages</h3>

<p>In all games and scenarios considered so far, both players always made the same observations. Even though observations may not always correspond to the actual actions, the observation errors were the same for both players. That information structure is called &ldquo;imperfect public monitoring&rdquo;. Yet, in many real world relationships parties do not neccessarily always make the same observations and one often does not know what the other party has observed. Games in which observations are noisy and can differ between players are called games with <strong>private monitoring</strong>. </p>

<p>In Scenario 2 we study a repeated prisoners&#39; dilemma game with private monitoring. As before player i observes with probability <em>err.D.prob</em> that the other player j has played &ldquo;D&rdquo;, even if in fact &ldquo;C&rdquo; was played. Yet, her own action is now always correctly observed by player i. The observation errors of player i and j are <em>independently distributed</em> from each other. This means a player j no longer knows whether player i has observed player j&#39;s action correctly, and vice versa. The actual observations of i and j can now differ.</p>

<p>I want to exemplify the information structure with a simple example with two strategies that always cooperate and don&#39;t use payments or messages.</p>

<pre><code class="r">library(StratTourn)
# Initialize game with private monitoring, by setting private.signals=TRUE
game = make.payment.message.pd.game(err.D.prob = 0.2, private.signals = TRUE)

# A simple strategy that always cooperates sends no message and makes no
# payment
coop.strat = function(obs, i, t, game, ...) {
    return(nlist(a = &quot;C&quot;, pay = 0, m = &quot;&quot;))
}

# Run coop.strat vs coop.strat and analyze output Note that I fix the number
# of rounds to 10 and provide a game.seed parameter which causes the random
# number generator to always return the same results.
res = run.rep.game(strat = nlist(coop.strat, coop.strat), game = game, delta = 0.98, 
    T.min = 10, T.max = 10, game.seed = 12345)
res
</code></pre>

<pre><code>## $hist
##     t obs_pay1 obs_pay2 obs_m1 obs_m2 obs_prand obs1_a1 obs1_a2 obs2_a1
## 1   1     &lt;NA&gt;     &lt;NA&gt;   &lt;NA&gt;   &lt;NA&gt;      &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;
## 2   2        0        0                   0.456       C       D       C
## 3   3        0        0                   0.509       C       C       C
## 4   4        0        0                   0.035       C       D       C
## 5   5        0        0                   0.001       C       C       C
## 6   6        0        0                   0.388       C       C       D
## 7   7        0        0                   0.952       C       C       C
## 8   8        0        0                   0.965       C       C       C
## 9   9        0        0                    0.39       C       C       C
## 10 10        0        0                   0.226       C       C       C
##    obs2_a2 a1 pay1 m1 a2 pay2 m2 pi1 pi2
## 1     &lt;NA&gt;  C    0     C    0      1   1
## 2        C  C    0     C    0      1   1
## 3        C  C    0     C    0      1   1
## 4        C  C    0     C    0      1   1
## 5        C  C    0     C    0      1   1
## 6        C  C    0     C    0      1   1
## 7        C  C    0     C    0      1   1
## 8        C  C    0     C    0      1   1
## 9        C  C    0     C    0      1   1
## 10       C  C    0     C    0      1   1
## 
## $u
## [1] 1 1
</code></pre>

<p>Columns 2-5 show the observations for payments, messages and the public signal, which are the same for both players. Columns 7-10 shows both players private observations about the actions.</p>

<pre><code class="r">res$hist[, 7:10]
</code></pre>

<pre><code>##    obs1_a1 obs1_a2 obs2_a1 obs2_a2
## 1     &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;    &lt;NA&gt;
## 2        C       D       C       C
## 3        C       C       C       C
## 4        C       D       C       C
## 5        C       C       C       C
## 6        C       C       D       C
## 7        C       C       C       C
## 8        C       C       C       C
## 9        C       C       C       C
## 10       C       C       C       C
</code></pre>

<p>The columns obs1_a1 and obs1_a2 show the action pair observed by player 1 and columns obs2_a1 and obs2_a2 show the action pair observed by player 2. You see that in periods 2 and 4 player 1 has wrongly observed that player 2 has defected. Yet player 2 does not know that player 1 has observed this defection. Similarly, in period 6 player 2 wrongly observes a defection by player 1.</p>

<p>While one can in principle use messages to tell the other player about the observations one has made, the game in itself does not prevent lies. A player has no method to prove her observations to the other player.</p>

<h3>Scenario 3: Public monitoring with a possibility to manipulate signals</h3>

<p>Another real world problem is that signals about behavior can sometimes be manipulated. One can try to make the own actions look good or sometimes sabotage the other parties appearance by making their actions look bad. Such possibilities can provide a severe challenge for cooperation. This scenario analyzes these issues in a simple setting. We are back to the case of imperfect public monitoring, like in Scenario 1, i.e. both players make the same observation. Yet, in addition to choosing an action a, payment pay and message m, players can choose to sabotage or not. This is decided by returning an action <strong>sab</strong> which can be TRUE (perform sabotage) or FALSE (no sabotage).</p>

<p>If player chooses to sabotage (sab=TRUE), we have the following effects:</p>

<ul>
<li><p>In the next period players always observe that player j has defected (D). This means sabotage makes the other  player always look like a defector.</p></li>
<li><p>Player i, who performs the sabotage, has to bear <strong>costs of sabotage c=0.3</strong>, which are directly reduced from i&#39;s payoff in the period in which the sabotage is conducted.</p></li>
</ul>

<p>We generate a game with such a sabotage opportunity with the following function call</p>

<pre><code class="r"># Generate game with sabotage option
game = make.payment.message.sabotage.pd.game(err.D.prob = err.D.prob, sabotage.cost = 0.3)
</code></pre>

<p>Here is an example run with a strategy that randomly sabotages.</p>

<pre><code class="r">random.sabotage = function(obs, i, t, game, ...) {
    # Sabotages with 30% probability
    return(nlist(a = &quot;C&quot;, pay = 0, m = &quot;&quot;, sab = runif(1) &lt;= 0.3))
}

run.rep.game(strat = c(random.sabotage, random.sabotage), game = game, delta = delta, 
    T.min = 10, T.max = 10, game.seed = 1235, strat.seed = 9876543)
</code></pre>

<pre><code>## $hist
##     t obs_a1 obs_a2 obs_pay1 obs_pay2 obs_m1 obs_m2 obs_prand a1 pay1 m1
## 1   1   &lt;NA&gt;   &lt;NA&gt;     &lt;NA&gt;     &lt;NA&gt;   &lt;NA&gt;   &lt;NA&gt;      &lt;NA&gt;  C    0   
## 2   2      C      D        0        0                   0.839  C    0   
## 3   3      C      C        0        0                   0.745  C    0   
## 4   4      C      C        0        0                   0.955  C    0   
## 5   5      D      D        0        0                   0.629  C    0   
## 6   6      C      D        0        0                   0.914  C    0   
## 7   7      C      C        0        0                   0.847  C    0   
## 8   8      C      C        0        0                   0.861  C    0   
## 9   9      C      C        0        0                   0.794  C    0   
## 10 10      C      C        0        0                   0.205  C    0   
##     sab1 a2 pay2 m2  sab2 pi1 pi2
## 1   TRUE  C    0    FALSE 0.7 1.0
## 2  FALSE  C    0    FALSE 1.0 1.0
## 3  FALSE  C    0    FALSE 1.0 1.0
## 4  FALSE  C    0     TRUE 1.0 0.7
## 5   TRUE  C    0    FALSE 0.7 1.0
## 6  FALSE  C    0    FALSE 1.0 1.0
## 7  FALSE  C    0    FALSE 1.0 1.0
## 8  FALSE  C    0    FALSE 1.0 1.0
## 9  FALSE  C    0    FALSE 1.0 1.0
## 10 FALSE  C    0    FALSE 1.0 1.0
## 
## $u
## [1] 0.9322 0.9679
</code></pre>

<p>You see that player 1 sabotages in periods 1 and 5 and that consequently in periods 2 and 6 it is observed that player 2 has defected. Furthermore, the payoff of player 1 the periods of sabotage is only 0.7 instead of 1. Similarly, player 2 sabotages in period 4 and in period 5 it is observed that player 1 defects. The observed defection of player 2 has nothing to do with sabotage but is simply a random observation error, caused by the positive err.D.prob.</p>

<p>Also note that <strong>sabotage actions are not directly observed</strong>.</p>

</body>

</html>

